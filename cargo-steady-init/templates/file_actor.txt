#[allow(unused_imports)]
use log::*;
use steady_state::*;
use steady_state::monitor::LocalMonitor;
use crate::Args;
use std::error::Error;
{% for u in message_types_to_use -%}
{{u}};
{%- endfor %}


//if no internal state is required (recommended) feel free to remove this.
#[derive(Default)]
struct {{ display_name|capitalize }}InternalState {
     {% for channel in rx_channels -%}
        {% if channel.copy && channel.batch_read>1 %}
              {{channel.name}}_buffer: [{{channel.message_type}}; {{channel.batch_read}}],
        {% endif -%}
     {%- endfor %}
     {% for channel in tx_channels -%}
         {% if channel.copy && channel.batch_write>1 %}
              {{channel.name}}_buffer: [{{channel.message_type}}; {{channel.batch_write}}],
         {% endif %}
     {% endfor %}
}
impl {{ display_name|capitalize }}InternalState {
    fn new(cli_args: &Args) -> Self {
        Self {
           //{{note_for_the_user}}: add custom arg based init here
           ..Default::default()
        }
    }
}




{% for st in message_types_to_define -%}
{{st}} {
   //{{note_for_the_user}}: add your fields here
}
{%- endfor %}
#[cfg(not(test))]
pub async fn run
    {%- for connection in rx_channels -%}
        <%- if connection.gurth>1 %>const {{connection.name|uppercase}}_GURTH:usize,<% endif -%>
    {%- endfor -%}
    {%- for connection in tx_channels -%}
        <%- if connection.gurth>1 %>const {{connection.name|uppercase}}_GURTH:usize,<% endif -%>
    {%- endfor -%}


  (context: SteadyContext
    {%- for connection in rx_channels %}
        ,{{connection.name}}_rx: <% if connection.gurth>1 %>SteadyRxBundle<{{connection.message_type}}, {{connection.name|uppercase}}_GURTH>
                                  <%- else %>SteadyRx<{{connection.message_type}}><% endif %>{%- endfor -%}
    {%- for connection in tx_channels %}
        ,{{connection.name}}_tx: <% if connection.gurth>1 %>SteadyTxBundle<{{connection.message_type}}, {{connection.name|uppercase}}_GURTH>
                                  <%- else %>SteadyTx<{{connection.message_type}}><% endif %>{%- endfor -%}
    ) -> Result<(),Box<dyn Error>> {

    let cli_args = context.args::<Args>();
    let mut state = if let Some(args) = cli_args {
        {{ display_name|capitalize }}InternalState::new(args)
    } else {
        {{ display_name|capitalize }}InternalState::default()
    }

    let mut monitor =  context.into_monitor([{% for connection in rx_channels %}
                        &{{connection.name}}_rx{%- if loop.last %}{% else -%}
                           ,{%- endif %}{% endfor %}], [{% for connection in tx_channels %}
                         &{{connection.name}}_tx{%- if loop.last %}{% else -%}
                            ,{%- endif %}{% endfor %}]);



 {% for connection in rx_channels -%}
    let mut {{connection.name}}_rx_guard = {{connection.name}}_rx.lock().await;
    let {{connection.name}}_rx = &mut *{{connection.name}}_rx_guard;
 {% endfor %}
 {% for connection in tx_channels %}
    let mut {{connection.name}}_tx_guard = {{connection.name}}_tx.lock().await;
    let {{connection.name}}_tx = &mut *{{connection.name}}_tx_guard;
 {%- endfor %}

    while monitor.is_running(&mut ||
 {%- for connection in rx_channels %}
    {{connection.name}}_rx.is_empty() && {{connection.name}}_rx.is_closed()
    {%- if loop.last %}{% else %} && {% endif -%}
 {% endfor %}
 {%- for connection in tx_channels %}
    {%- if loop.first && !rx_channels.is_empty() %} && {% else %}{% endif -%}
    {{connection.name}}_tx.mark_closed()
    {%- if loop.last %}{% else %} && {% endif -%}
 {% endfor %}
    ) {

     //these are cancel safe checks based on our desired driving rules

     //join all the rx and tx events so we can watch for them

     //if perioic is used we either
     //   wait for join fallowed my remaining periodic time
     //   selct! on peroic and joined events
     //works for both Bundles and non bundles




         process_once(&mut monitor, &mut state
          {%- for connection in rx_channels %}
             , {{connection.name}}_rx{%- endfor -%}
          {%- for connection in tx_channels %}
             , {{connection.name}}_tx{%- endfor -%}
         ).await;


    }
    Ok(())
}


async fn process_once<const R: usize, const T: usize>(monitor: & mut LocalMonitor<R,T>
                          , state: &mut {{ display_name|capitalize }}InternalState
                          {%- for channel in rx_channels %}
                             , {{channel.name}}_rx: &mut Rx<{{channel.message_type}}>{% endfor %}
                          {%- for channel in tx_channels %}
                             , {{channel.name}}_tx: &mut Tx<{{channel.message_type}}>{% endfor %}) {



   //peek slice, take slice or take single all done here but not nested since it must be written
   //  use the non asyc versions since we already waited.

 //for bundles we must use the locks here?

 //{{note_for_the_user}}: put your implementation here

}

#[cfg(test)]
pub async fn run(context: SteadyContext
                {%- for connection in rx_channels %}
                    ,{{connection.name}}_rx: SteadyRx<{{connection.message_type}}>
                {%- endfor -%}
                {%- for connection in tx_channels %}
                    ,{{connection.name}}_tx: SteadyTx<{{connection.message_type}}>
                {%- endfor -%}) -> Result<(),Box<dyn Error>> {



}


